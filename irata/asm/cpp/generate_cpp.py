#!/usr/bin/env python3

import sys
import os

# Add parent directory to sys.path to allow importing loader.py
sys.path.insert(0,
                os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from loader import load_and_validate


def format_addressing_mode(addressing_mode) -> str:
    return f'AddressingMode::{addressing_mode.upper()}'


def format_instruction(instruction) -> str:
    return f"""
Instruction{{
    .name = "{instruction["name"]}",
    .opcode = {instruction["opcode"]},
    .addressing_mode = {format_addressing_mode(instruction["addressing_mode"])},
    .description = "{instruction["description"]}",
}},
"""


def format_instructions(config) -> str:
    return "".join(
        format_instruction(instruction)
        for instruction in config["instructions"])


def format_cpp(config) -> str:
    return f"""// Generated by generate_cpp.py
// Do not edit manually!

#include <irata/asm/asm.hpp>
#include <vector>

namespace irata::asm_ {{
const std::vector<Instruction> instruction_table = {{
{format_instructions(config)}
}};
}}
"""


if __name__ == '__main__':
    if len(sys.argv) != 2:
        print("Usage: python generate_cpp.py <output_file>")
        sys.exit(1)
    output_file = sys.argv[1]
    print(
        f"Generating C++ code for IRATA assembly instructions into {output_file}"
    )

    config = load_and_validate()
    print("Loaded config:")
    print(config)

    with open(output_file, "w") as f:
        f.write(format_cpp(config))
