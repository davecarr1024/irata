#!/usr/bin/env python3

import sys
import os

# Add parent directory to sys.path to allow importing loader.py
sys.path.insert(0,
                os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from loader import load_and_validate


def format_addressing_mode(addressing_mode) -> str:
    tokens = addressing_mode.split('_')
    return f"AddressingMode::{''.join(token.capitalize() for token in tokens)}"


def format_instruction(instruction) -> str:
    opcode_hex = f"0x{instruction['opcode']:02X}"
    return f"""
        Instruction(
            "{instruction["name"]}",
            Byte({opcode_hex}),
            {format_addressing_mode(instruction["addressing_mode"])},
            "{instruction["description"]}"
        ),"""


def format_instructions(config) -> str:
    return "".join(
        format_instruction(instruction)
        for instruction in config["instructions"])


def format_cpp(config) -> str:
    return f"""// Generated by generate_cpp.py
// Do not edit manually!

#include <irata/asm/instruction.hpp>
#include <irata/common/bytes/byte.hpp>
#include <vector>

namespace irata::asm_ {{

using Byte = common::bytes::Byte;

const std::set<Instruction>& Instruction::irata() {{
    static const std::set<Instruction> instruction_table = {{
        {format_instructions(config)}
    }};
    return instruction_table;
}}

}} // namespace irata::asm_
"""


if __name__ == '__main__':
    if len(sys.argv) != 2:
        print("Usage: python generate_cpp.py <output_file>")
        sys.exit(1)
    output_file = sys.argv[1]
    print(
        f"Generating C++ code for IRATA assembly instructions into {output_file}"
    )

    config = load_and_validate()
    print("Loaded config:")
    print(config)

    with open(output_file, "w") as f:
        f.write(format_cpp(config))
